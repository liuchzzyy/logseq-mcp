# Logseq MCP Server 中文指南

> **版本**: 1.1.0 | **Python**: >=3.10 | **协议**: MCP (Model Context Protocol)
>
> 本文档是对 `logseq-mcp` 项目的完整框架逻辑和实现细节的中文整理。

---

## 目录

1. [项目概述](#1-项目概述)
2. [架构总览](#2-架构总览)
3. [目录结构](#3-目录结构)
4. [启动流程与入口](#4-启动流程与入口)
5. [Layer 4: 基础设施层](#5-layer-4-基础设施层)
6. [Layer 3: 领域模型层](#6-layer-3-领域模型层)
7. [Layer 2: 应用服务层](#7-layer-2-应用服务层)
8. [Layer 1: 表现层（MCP 协议）](#8-layer-1-表现层mcp-协议)
9. [工具函数与错误处理](#9-工具函数与错误处理)
10. [CLI 命令行接口](#10-cli-命令行接口)
11. [完整工具清单](#11-完整工具清单)
12. [数据流转示例](#12-数据流转示例)
13. [测试体系](#13-测试体系)
14. [CI/CD 流水线](#14-cicd-流水线)
15. [配置与部署](#15-配置与部署)
16. [依赖关系图](#16-依赖关系图)

---

## 1. 项目概述

`logseq-mcp` 是一个 **Model Context Protocol (MCP) 服务器**，提供与 Logseq 知识库的直接集成。它使 LLM（大语言模型）能够通过标准化协议与 Logseq 图谱交互，执行页面创建、块管理、查询等操作。

### 核心能力

| 维度 | 说明 |
|------|------|
| MCP Tools | 25 个工具，覆盖块/页面/编辑/查询/图谱/Git 六大类 |
| MCP Prompts | 6 个提示模板，覆盖常用工作流 |
| 架构 | 四层分层架构（基础设施 → 领域 → 应用 → 表现） |
| 类型安全 | 全面使用 Pydantic v2 模型验证 |
| 容错机制 | Tenacity 重试 + 指数退避 |
| 测试覆盖 | 158 个测试，87% 覆盖率 |
| CLI | 40+ 子命令，支持直接操作 Logseq |

### 重构历程

本项目从 v0.0.1 的单文件架构（9 个 Tools）重构为 v1.1.0 的四层架构（25 个 Tools），重构计划详见 `plan.md`。

---

## 2. 架构总览

```
┌─────────────────────────────────────────────────────┐
│  Layer 1: 表现层 (Presentation)                      │
│  ├── handlers/tools.py    → 25 个 MCP Tool 处理器    │
│  └── handlers/prompts.py  → 6 个 MCP Prompt 处理器   │
├─────────────────────────────────────────────────────┤
│  Layer 2: 应用服务层 (Application)                   │
│  ├── services/blocks.py   → Block 业务逻辑           │
│  ├── services/pages.py    → Page 业务逻辑            │
│  ├── services/queries.py  → Query 业务逻辑           │
│  └── services/graph.py    → Graph/Git 业务逻辑       │
├─────────────────────────────────────────────────────┤
│  Layer 3: 领域模型层 (Domain)                        │
│  ├── models/enums.py      → 枚举定义                 │
│  ├── models/schemas.py    → Pydantic 输入模型        │
│  └── models/responses.py  → 输出实体 + 格式化器      │
├─────────────────────────────────────────────────────┤
│  Layer 4: 基础设施层 (Infrastructure)                │
│  ├── client/base.py       → HTTP 客户端抽象基类      │
│  ├── client/logseq.py     → Logseq API 客户端实现    │
│  └── config/settings.py   → 配置管理 (Pydantic)      │
└─────────────────────────────────────────────────────┘
```

**设计原则**: 上层依赖下层，下层不依赖上层。每层职责单一：
- **基础设施层**: 负责 HTTP 通信和配置读取
- **领域模型层**: 定义数据结构、输入验证和输出格式化
- **应用服务层**: 封装业务逻辑，协调客户端调用与实体转换
- **表现层**: 处理 MCP 协议的 Tool/Prompt 路由与响应构建

---

## 3. 目录结构

```
src/
├── __init__.py              # 包入口，导出 main
├── __main__.py              # python -m src 入口
├── server.py                # MCP Server 初始化与注册
│
├── client/                  # 基础设施层 - HTTP 客户端
│   ├── __init__.py
│   ├── base.py              # BaseAPIClient 抽象基类 (重试/认证/超时)
│   ├── logseq.py            # LogseqClient 具体实现 (30+ API 方法)
│   └── cli.py               # CLI 命令行入口 (argparse, 40+ 子命令)
│
├── config/                  # 基础设施层 - 配置
│   ├── __init__.py
│   └── settings.py          # LogseqSettings (Pydantic Settings 单例)
│
├── models/                  # 领域模型层
│   ├── __init__.py
│   ├── enums.py             # ToolName (25项), PageFormat, BlockMarker, Priority
│   ├── schemas.py           # 15+ Pydantic 输入模型 (严格校验)
│   └── responses.py         # BlockEntity, PageEntity, GraphEntity, Formatters
│
├── services/                # 应用服务层
│   ├── __init__.py
│   ├── blocks.py            # BlockService (12 个 async 方法 + 1 格式化)
│   ├── pages.py             # PageService (6 个 async 方法 + 2 格式化)
│   ├── queries.py           # QueryService (4 个 async 方法)
│   └── graph.py             # GraphService (4 个 async 方法)
│
├── handlers/                # 表现层
│   ├── __init__.py
│   ├── tools.py             # ToolHandler (25 个 Tool 定义 + 路由)
│   └── prompts.py           # PromptHandler (6 个 Prompt 定义 + 路由)
│
└── utils/                   # 工具函数
    ├── __init__.py
    └── errors.py            # 异常层级 + McpError 转换

tests/
├── conftest.py              # pytest 配置 (添加 src 到 path)
├── test_client.py           # HTTP 客户端测试 (覆盖率 97-100%)
├── test_models.py           # 模型验证测试 (覆盖率 94-100%)
├── test_services.py         # 服务层测试 (覆盖率 100%)
└── test_handlers.py         # 处理器测试 (覆盖率 99-100%)
```

---

## 4. 启动流程与入口

### 4.1 MCP Server 启动 (`src/server.py`)

这是核心入口，负责组装所有组件并启动 MCP 服务器：

```
serve()
  │
  ├─ 1. 创建 MCP Server 实例
  │     server = Server(settings.server_name)
  │
  ├─ 2. 初始化 LogseqClient (HTTP 客户端)
  │     client = LogseqClient(base_url, api_key, timeout, max_retries)
  │
  ├─ 3. 初始化四个服务
  │     BlockService(client)
  │     PageService(client)
  │     QueryService(client)
  │     GraphService(client)
  │
  ├─ 4. 初始化两个处理器
  │     ToolHandler(block_svc, page_svc, query_svc, graph_svc)
  │     PromptHandler(block_svc, page_svc)
  │
  ├─ 5. 注册 MCP 协议回调
  │     @server.list_tools()    → tool_handler.get_tools()
  │     @server.call_tool()     → tool_handler.handle_tool()
  │     @server.list_prompts()  → prompt_handler.get_prompts()
  │     @server.get_prompt()    → prompt_handler.handle_prompt()
  │
  └─ 6. 启动 stdio 传输
        async with stdio_server() as (read, write):
            await server.run(read, write, options)
```

### 4.2 CLI 入口 (`src/client/cli.py`)

除了 MCP Server 模式，还提供了完整的命令行接口（代码位于 `src/client/cli.py`，由 `src/__init__.py` 和 `src/__main__.py` 导入）：

```
main()
  │
  ├─ load_dotenv()                    # 加载 .env
  ├─ argparse 解析                    # 解析命令行参数
  ├─ _load_api_credentials(args)      # 从 args/env/settings 获取凭证
  │
  ├─ command == "serve" → asyncio.run(serve())    # 启动 MCP 服务器
  │
  └─ 其他命令 → _build_services() → 执行对应操作
       ├── pages   → list / get / create / delete / rename
       ├── journals → create / list
       ├── blocks  → get / insert / update / delete / move / batch-insert / ...
       ├── queries → simple / advanced / tasks / blocks-with-prop
       └── graph   → info / user-configs / git-status
```

### 4.3 入口文件 (`src/__main__.py`)

```python
from .client.cli import main
main()
```

通过 `uv run logseq-mcp` 或 `uv run python -m src` 启动。

---

## 5. Layer 4: 基础设施层

### 5.1 配置管理 (`src/config/settings.py`)

使用 `pydantic-settings` 实现的环境变量配置管理：

```python
class LogseqSettings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=".env",
        env_prefix="LOGSEQ_",     # 所有环境变量以 LOGSEQ_ 开头
        extra="ignore"
    )

    # 核心配置
    api_token: str               # LOGSEQ_API_TOKEN (必填)
    api_url: str = "http://localhost:12315"  # LOGSEQ_API_URL
    api_timeout: int = 10        # LOGSEQ_API_TIMEOUT
    api_max_retries: int = 3     # LOGSEQ_API_MAX_RETRIES

    # 服务器元信息
    server_name: str = "logseq-mcp"
    server_version: str = Field(default_factory=_get_version)  # 从 pyproject.toml 读取

    # 功能开关
    enable_advanced_queries: bool = True
    enable_git_operations: bool = False
    enable_asset_management: bool = False
```

**全局单例**: `settings = LogseqSettings()` 在模块加载时实例化。

**配置优先级**: CLI 参数 > 环境变量 > .env 文件 > 默认值

### 5.2 HTTP 客户端基类 (`src/client/base.py`)

抽象基类，提供通用 HTTP 请求能力：

**核心机制**:
- **认证**: Bearer Token 方式 (`Authorization: Bearer {api_key}`)
- **重试**: Tenacity `@retry` 装饰器，指数退避（1s → 2s → 4s...，最多 10s）
- **超时**: 默认 10 秒，支持每次请求自定义
- **错误映射**: HTTP 401 → AuthenticationError, 404 → NotFoundError, 5xx → APIError

```python
class BaseAPIClient(ABC):
    def __init__(self, base_url, api_key, timeout=10, max_retries=3):
        self.session = requests.Session()
        self.session.headers = {
            "Authorization": f"Bearer {api_key}",
            "Content-Type": "application/json"
        }

    @retry(stop=stop_after_attempt(3), wait=wait_exponential(...))
    def _make_request(self, method: str, args: list, timeout=None) -> dict:
        # POST {base_url}/api  body: {"method": method, "args": args}
        ...

    @abstractmethod
    def health_check(self) -> bool: ...
```

**请求格式**: 所有请求都是 POST 到 `/api` 端点，body 为 `{"method": "logseq.xxx.yyy", "args": [...]}`

### 5.3 Logseq API 客户端 (`src/client/logseq.py`)

继承 `BaseAPIClient`，封装 30+ 个 Logseq HTTP API 方法：

| API 分类 | 方法 | Logseq API |
|----------|------|-----------|
| **Editor (块)** | `insert_block(parent, content)` | `logseq.Editor.insertBlock` |
| | `update_block(uuid, content)` | `logseq.Editor.updateBlock` |
| | `delete_block(uuid)` | `logseq.Editor.removeBlock` |
| | `get_block(uuid)` | `logseq.Editor.getBlock` |
| | `move_block(uuid, target)` | `logseq.Editor.moveBlock` |
| | `insert_batch_blocks(parent, blocks)` | `logseq.Editor.insertBatchBlock` |
| | `get_page_blocks_tree(page)` | `logseq.Editor.getPageBlocksTree` |
| | `get_current_page_blocks_tree()` | `logseq.Editor.getCurrentPageBlocksTree` |
| | `get_current_block()` | `logseq.Editor.getCurrentBlock` |
| | `get_current_page()` | `logseq.Editor.getCurrentPage` |
| | `edit_block(uuid, pos)` | `logseq.Editor.editBlock` |
| | `exit_editing_mode(select)` | `logseq.Editor.exitEditingMode` |
| | `get_editing_block_content()` | `logseq.Editor.getEditingBlockContent` |
| **Page (页)** | `create_page(name, props)` | `logseq.Editor.createPage` |
| | `get_page(identifier)` | `logseq.Editor.getPage` |
| | `get_all_pages(repo)` | `logseq.Editor.getAllPages` |
| | `delete_page(name)` | `logseq.Editor.deletePage` |
| | `rename_page(old, new)` | `logseq.Editor.renamePage` |
| **Query (查询)** | `q(query)` | `logseq.DB.q` |
| | `datascript_query(query)` | `logseq.DB.datascriptQuery` |
| **App (应用)** | `get_current_graph()` | `logseq.App.getCurrentGraph` |
| | `get_user_configs()` | `logseq.App.getUserConfigs` |
| | `show_msg(content, status)` | `logseq.UI.showMsg` |
| **Git** | `git_commit(message)` | `logseq.Git.commit` |
| | `git_status()` | `logseq.Git.status` |

---

## 6. Layer 3: 领域模型层

### 6.1 枚举定义 (`src/models/enums.py`)

```python
class ToolName(str, Enum):      # 25 个工具名，如 "logseq_insert_block"
class PageFormat(str, Enum):    # "markdown" | "org"
class BlockMarker(str, Enum):   # TODO, DOING, DONE, NOW, LATER, WAITING, CANCELLED
class Priority(str, Enum):      # A (高), B (中), C (低)
```

### 6.2 输入模型 (`src/models/schemas.py`)

所有模型继承自 `LogseqBaseModel`，配置 `extra="forbid"` (禁止多余字段) + `validate_assignment=True`：

| 模型 | 用途 | 必填字段 | 可选字段 |
|------|------|---------|---------|
| **InsertBlockInput** | 插入块 | content | parent_block, is_page_block, before, custom_uuid, properties |
| **UpdateBlockInput** | 更新块 | uuid, content | properties |
| **DeleteBlockInput** | 删除块 | uuid | - |
| **GetBlockInput** | 获取块 | uuid | - |
| **MoveBlockInput** | 移动块 | uuid, target_uuid | as_child |
| **BatchBlockInput** | 批量插入 | parent, blocks | - |
| **CreatePageInput** | 创建页面 | page_name | properties, journal, format, create_first_block |
| **GetPageInput** | 获取页面 | page_name | include_children |
| **DeletePageInput** | 删除页面 | page_name | - |
| **RenamePageInput** | 重命名页面 | old_name, new_name | - |
| **GetAllPagesInput** | 列出页面 | - | repo |
| **EditBlockInput** | 编辑模式 | uuid | pos (0-10000) |
| **ExitEditingInput** | 退出编辑 | - | select_block |
| **SimpleQueryInput** | 简单查询 | query | - |
| **AdvancedQueryInput** | 高级查询 | query | inputs |
| **GetTasksInput** | 获取任务 | - | marker, priority |
| **GitCommitInput** | Git 提交 | message | - |
| **EmptyInput** | 无参操作 | - | - |

**特殊验证器**:
- `InsertBlockInput.clean_block_refs`: 自动清理 `((uuid))` 格式为 `uuid`
- `CreatePageInput.parse_properties`: 支持 JSON 字符串自动解析为字典

### 6.3 输出实体与格式化 (`src/models/responses.py`)

#### 实体类

```python
class BlockEntity(BaseModel):
    uuid: str
    content: str
    page: dict[str, Any] | int    # API 可能返回整数 ID
    parent: dict[str, Any] | int | None
    children: list[BlockEntity]   # 递归嵌套
    properties: dict[str, Any]
    marker: str | None            # TODO/DONE 等
    priority: str | None          # A/B/C

    @classmethod
    def from_api(cls, data: dict) -> BlockEntity:
        """工厂方法：从 API 响应构建实体，递归处理 children"""

class PageEntity(BaseModel):
    uuid: str
    name: str
    original_name: str | None
    journal_day: int | None
    properties: dict
    properties_text_values: dict
    updated_at: str | int | None
    created_at: str | int | None

    @classmethod
    def from_api(cls, data: dict) -> PageEntity: ...

class GraphEntity(BaseModel):
    name: str
    path: str
    url: str | None
    version: str | None
```

#### Formatters 格式化工具类

所有方法均为 `@staticmethod`，将实体转为人类可读的文本：

| 方法 | 功能 |
|------|------|
| `format_block(block, level)` | 格式化单个块，支持缩进层级 |
| `format_blocks(blocks)` | 格式化块列表 |
| `format_page(page)` | 格式化页面信息 (名称、UUID、属性) |
| `format_pages(pages)` | 格式化页面列表 (按名称排序) |
| `format_graph(graph)` | 格式化图谱信息 |
| `format_query_results(results)` | 格式化查询结果 (编号列表) |
| `format_git_status(status)` | 格式化 Git 状态 |

---

## 7. Layer 2: 应用服务层

所有服务类接收 `LogseqClient` 实例，提供异步方法，内部协调客户端调用与实体转换。

### 7.1 BlockService (`src/services/blocks.py`)

```python
class BlockService:
    def __init__(self, client: LogseqClient): ...

    # CRUD 操作
    async def insert(input: InsertBlockInput) -> BlockEntity
    async def update(input: UpdateBlockInput) -> BlockEntity | bool
    async def delete(input: DeleteBlockInput) -> bool
    async def get(input: GetBlockInput) -> BlockEntity
    async def move(input: MoveBlockInput) -> BlockEntity | bool
    async def insert_batch(input: BatchBlockInput) -> list[BlockEntity] | bool

    # 页面/块读取
    async def get_page_blocks(page_name: str) -> list[BlockEntity]
    async def get_current_page_blocks() -> list[BlockEntity]
    async def get_current_block() -> BlockEntity | None

    # 编辑器操作
    async def edit_block(uuid: str, pos: int = 0) -> None
    async def exit_editing_mode(select_block: bool = False) -> None
    async def get_editing_content() -> Any

    def format_block_tree(blocks) -> str   # 委托给 Formatters
```

**实现细节**:
- `insert()` 将 Pydantic 模型字段映射为 Logseq API 选项（snake_case → camelCase）
- 过滤掉值为 `None` 的选项，避免传递无效参数
- 所有返回的 API 响应通过 `BlockEntity.from_api()` 统一转换
- `update()` / `move()` / `insert_batch()` 正确处理 Logseq API 返回 `null` 的情况，返回 `True` 表示成功
- 编辑器方法 (`edit_block` / `exit_editing_mode` / `get_editing_content`) 直接调用 Logseq Editor API

### 7.2 PageService (`src/services/pages.py`)

```python
class PageService:
    async def create(input: CreatePageInput) -> PageEntity
    async def get(input: GetPageInput) -> PageEntity
    async def get_all(input: GetAllPagesInput) -> list[PageEntity]
    async def get_current_page() -> PageEntity | None
    async def delete(input: DeletePageInput) -> bool
    async def rename(input: RenamePageInput) -> bool

    def format_page(page: PageEntity) -> str       # 委托给 Formatters
    def format_pages(pages: list[PageEntity]) -> str
```

### 7.3 QueryService (`src/services/queries.py`)

```python
class QueryService:
    async def simple_query(input: SimpleQueryInput) -> list[Any]
    async def advanced_query(input: AdvancedQueryInput) -> list[Any]
    async def get_tasks(input: GetTasksInput) -> list[dict]
    async def get_blocks_with_property(property_name, value=None) -> list[dict]
```

**`get_tasks` 实现逻辑**:
1. 使用 DataScript 查询所有带 marker 的块
2. 在内存中按 `marker` 和 `priority` 过滤

**`get_blocks_with_property` 实现逻辑**:
- 动态构建 DataScript 查询语句，按属性名和值筛选块

### 7.4 GraphService (`src/services/graph.py`)

```python
class GraphService:
    async def get_current_graph(input: EmptyInput) -> GraphEntity
    async def get_user_configs(input: EmptyInput) -> dict
    async def git_commit(input: GitCommitInput) -> bool
    async def git_status(input: EmptyInput) -> str | dict
```

---

## 8. Layer 1: 表现层（MCP 协议）

### 8.1 ToolHandler (`src/handlers/tools.py`)

**职责**: 定义 MCP Tool 元数据，路由 Tool 调用到对应的 Service 方法。

#### 工具定义

`get_tools()` 返回 25 个 `Tool` 对象，每个包含：
- `name`: 工具名称（来自 `ToolName` 枚举）
- `description`: 工具描述
- `inputSchema`: 由 Pydantic 模型的 `model_json_schema()` 自动生成

#### 路由逻辑

`handle_tool(name, arguments)` 使用 Python 3.10 的 `match/case` 语法路由：

```python
async def handle_tool(self, name, arguments) -> Sequence[TextContent]:
    match name:
        case ToolName.INSERT_BLOCK:
            result = await self.block_service.insert(InsertBlockInput(**arguments))
            text = self.block_service.format_block_tree([result])
        case ToolName.UPDATE_BLOCK:
            ...
        case _:
            raise ValueError(f"Unknown tool: {name}")

    return [TextContent(type="text", text=text)]
```

**错误处理**: `try/except` 捕获所有异常，通过 `format_error()` 转换为 `McpError`。

### 8.2 PromptHandler (`src/handlers/prompts.py`)

**职责**: 定义 MCP Prompt 模板，将用户意图转为结构化提示消息。

#### 6 个 Prompt 定义

| Prompt | 参数 | 描述 |
|--------|------|------|
| `logseq_insert_block` | content (必填), parent_block | 插入块 |
| `logseq_create_page` | page_name (必填), properties | 创建页面 |
| `logseq_get_page` | page_name (必填) | 获取页面 |
| `logseq_get_current_page` | (无) | 获取当前页面 |
| `logseq_get_all_pages` | (无) | 列出所有页面 |
| `logseq_simple_query` | query (必填) | 执行查询 |

#### 响应格式

返回 `GetPromptResult` 包含 `PromptMessage`，角色为 `"user"`，内容为构造的自然语言指令。

---

## 9. 工具函数与错误处理

### 异常层级 (`src/utils/errors.py`)

```
LogseqError (基类)
├── AuthenticationError   → API 认证失败 (HTTP 401)
├── ConnectionError       → 连接失败 / 超时
├── NotFoundError         → 资源未找到 (HTTP 404)
├── APIError              → API 请求失败 (HTTP 5xx)
└── ValidationError       → 输入验证失败
```

### MCP 错误转换

`format_error(e: Exception) -> McpError`:
- `AuthenticationError` / `ConnectionError` / `APIError` → `INTERNAL_ERROR`
- `NotFoundError` / `ValidationError` → `INVALID_PARAMS`
- 其他异常 → `INTERNAL_ERROR` + "Unexpected error"

---

## 10. CLI 命令行接口

项目提供完整的命令行界面 (`src/client/cli.py`)，无需 MCP 客户端即可直接操作 Logseq。

### 命令结构

```bash
uv run logseq-mcp [--api-key KEY] [--url URL] <command> <action> [options]
```

### 命令列表

```bash
# 启动 MCP 服务器 (默认)
uv run logseq-mcp serve

# 页面操作
uv run logseq-mcp pages list [--repo NAME]
uv run logseq-mcp pages get --name "页面名" [--children]
uv run logseq-mcp pages create --name "新页面" [--properties '{"key":"val"}'] [--journal]
uv run logseq-mcp pages delete --name "页面名"
uv run logseq-mcp pages rename --old "旧名" --new "新名"

# 日志操作
uv run logseq-mcp journals create --name "2026-02-06"
uv run logseq-mcp journals list

# 块操作
uv run logseq-mcp blocks get --uuid <uuid>
uv run logseq-mcp blocks insert --parent "页面名" --content "内容" [--as-page-block]
uv run logseq-mcp blocks update --uuid <uuid> --content "新内容"
uv run logseq-mcp blocks delete --uuid <uuid>
uv run logseq-mcp blocks move --uuid <uuid> --target <target_uuid> [--as-child]
uv run logseq-mcp blocks batch-insert --parent "页面名" --file blocks.json
uv run logseq-mcp blocks page-blocks --page "页面名"
uv run logseq-mcp blocks current-page-blocks
uv run logseq-mcp blocks current-block

# 查询操作
uv run logseq-mcp queries simple --query "[[标签]]"
uv run logseq-mcp queries advanced --query "[:find ...]" [--inputs '[...]']
uv run logseq-mcp queries tasks [--marker TODO] [--priority A]
uv run logseq-mcp queries blocks-with-prop --property status [--value done]

# 图谱操作
uv run logseq-mcp graph info
uv run logseq-mcp graph user-configs
uv run logseq-mcp graph git-status
```

### 凭证加载优先级

1. `--api-key` / `--url` 命令行参数
2. `LOGSEQ_API_TOKEN` / `LOGSEQ_API_URL` 环境变量
3. `settings.py` 中的 Pydantic Settings（读取 .env 文件）

---

## 11. 完整工具清单

### Block 操作 (8 个)

| 工具名 | 描述 | 输入模型 |
|--------|------|---------|
| `logseq_insert_block` | 插入新块 | InsertBlockInput |
| `logseq_update_block` | 更新块内容 | UpdateBlockInput |
| `logseq_delete_block` | 删除块 | DeleteBlockInput |
| `logseq_get_block` | 获取块详情 | GetBlockInput |
| `logseq_move_block` | 移动块位置 | MoveBlockInput |
| `logseq_insert_batch` | 批量插入块 | BatchBlockInput |
| `logseq_get_page_blocks` | 获取页面块树 | GetPageInput |
| `logseq_get_current_page_content` | 获取当前页面所有块 | EmptyInput |

### Page 操作 (5 个)

| 工具名 | 描述 | 输入模型 |
|--------|------|---------|
| `logseq_create_page` | 创建新页面 | CreatePageInput |
| `logseq_get_page` | 获取页面详情 | GetPageInput |
| `logseq_delete_page` | 删除页面 | DeletePageInput |
| `logseq_rename_page` | 重命名页面 | RenamePageInput |
| `logseq_get_all_pages` | 列出所有页面 | GetAllPagesInput |

### Editor 操作 (5 个)

| 工具名 | 描述 | 输入模型 |
|--------|------|---------|
| `logseq_get_current_page` | 获取当前活动页面 | EmptyInput |
| `logseq_get_current_block` | 获取当前聚焦块 | EmptyInput |
| `logseq_edit_block` | 进入块编辑模式 | EditBlockInput |
| `logseq_exit_editing_mode` | 退出编辑模式 | ExitEditingInput |
| `logseq_get_editing_content` | 获取正在编辑的内容 | EmptyInput |

### Query 操作 (3 个)

| 工具名 | 描述 | 输入模型 |
|--------|------|---------|
| `logseq_simple_query` | 简单查询 (如 `[[tag]]`) | SimpleQueryInput |
| `logseq_advanced_query` | DataScript 高级查询 | AdvancedQueryInput |
| `logseq_get_tasks` | 获取任务 (可按状态/优先级过滤) | GetTasksInput |

### Graph 操作 (2 个)

| 工具名 | 描述 | 输入模型 |
|--------|------|---------|
| `logseq_get_current_graph` | 获取当前图谱信息 | EmptyInput |
| `logseq_get_user_configs` | 获取用户配置 | EmptyInput |

### Git 操作 (2 个)

| 工具名 | 描述 | 输入模型 |
|--------|------|---------|
| `logseq_git_commit` | 执行 Git 提交 | GitCommitInput |
| `logseq_git_status` | 查看 Git 状态 | EmptyInput |

---

## 12. 数据流转示例

### 示例：通过 MCP 插入一个块

```
LLM Client
  │  调用 Tool: logseq_insert_block
  │  参数: {"parent_block": "[[项目]]", "content": "- 新任务"}
  ▼
ToolHandler.handle_tool("logseq_insert_block", {...})
  │  match → ToolName.INSERT_BLOCK
  │  构建: InsertBlockInput(**arguments)    ← Pydantic 验证
  │  调用: block_service.insert(input_data)
  ▼
BlockService.insert(input_data)
  │  映射选项: isPageBlock, before, customUUID, properties
  │  过滤 None 值
  │  调用: client.insert_block(parent, content, **options)
  ▼
LogseqClient.insert_block(parent, content, **options)
  │  调用: _make_request("logseq.Editor.insertBlock", [parent, content, options])
  ▼
BaseAPIClient._make_request(method, args)
  │  POST http://localhost:12315/api
  │  body: {"method": "logseq.Editor.insertBlock", "args": [...]}
  │  ← Tenacity 重试 (最多 3 次, 指数退避)
  │  ← 错误映射: 401→AuthError, 404→NotFound, 5xx→APIError
  ▼
Logseq HTTP API
  │  返回 JSON 响应
  ▼
BlockEntity.from_api(response)
  │  构建实体对象 (递归处理 children)
  ▼
Formatters.format_block(entity)
  │  生成人类可读文本: "- 新任务"
  ▼
TextContent(type="text", text=formatted_text)
  │  返回给 LLM Client
  ▼
LLM Client 收到结果
```

---

## 13. 测试体系

### 测试金字塔

```
       /\           E2E 测试 (5%)  — MCP 协议一致性
      /  \
     /____\         集成测试 (15%) — Handler 层测试
    /      \
   /________\       单元测试 (80%) — Client/Service/Model
```

### 测试文件与覆盖率

| 文件 | 测试对象 | 覆盖率 |
|------|---------|-------|
| `test_client.py` | BaseAPIClient 初始化、HTTP 请求、错误处理、重试逻辑 | 97-100% |
| `test_models.py` | Pydantic 模型验证、字段默认值、约束、from_api 工厂方法 | 94-100% |
| `test_services.py` | 四个 Service 的 async 方法（使用 mock client） | 100% |
| `test_handlers.py` | Tool 定义数量(25)、Schema 验证、Tool/Prompt 路由 | 99-100% |

### 测试工具栈

- **pytest** + **pytest-asyncio**: 异步测试支持
- **pytest-cov**: 覆盖率报告
- **pytest-mock**: Mock 支持
- **respx**: HTTP 请求 mock
- **factory-boy** + **faker**: 测试数据生成

### 运行测试

```bash
# 全部测试
uv run python -m pytest tests/

# 带覆盖率
uv run python -m pytest tests/ --cov=src --cov-report=html

# 指定文件
uv run python -m pytest tests/test_services.py -v
```

---

## 14. CI/CD 流水线

文件: `.github/workflows/ci.yml`

### 触发条件

- Push 到 `main` / `master`
- Pull Request

### 作业流程

```
┌─────────┐     ┌─────────┐
│  test   │ ──→ │  build  │
└─────────┘     └─────────┘
```

**test** (矩阵: Python 3.10 / 3.11 / 3.12):
1. `ruff check` — 代码风格检查
2. `ruff format --check` — 格式化检查
3. `ty check` — 类型检查
4. `pytest --cov` — 测试 + 覆盖率上报 Codecov

**build**: 构建 Python 包 (`uv build`)

---

## 15. 配置与部署

### 环境变量

| 变量 | 必填 | 默认值 | 说明 |
|------|------|--------|------|
| `LOGSEQ_API_TOKEN` | 是 | - | Logseq API 授权令牌 |
| `LOGSEQ_API_URL` | 否 | `http://localhost:12315` | Logseq HTTP API 地址 |
| `LOGSEQ_API_TIMEOUT` | 否 | `10` | 请求超时（秒） |
| `LOGSEQ_API_MAX_RETRIES` | 否 | `3` | 最大重试次数 |

### 获取 API Token

1. 打开 Logseq
2. 进入 **Settings → HTTP API Server**
3. 启用 HTTP API Server
4. 点击 "Authorization tokens"
5. 生成新令牌

### Claude Desktop 配置

```json
{
  "mcpServers": {
    "logseq": {
      "command": "uv",
      "args": ["--directory", "/path/to/logseq-mcp", "run", "logseq-mcp"],
      "env": {
        "LOGSEQ_API_TOKEN": "<你的令牌>",
        "LOGSEQ_API_URL": "http://127.0.0.1:12315"
      }
    }
  }
}
```

### 从源码运行

```bash
git clone https://github.com/dailydaniel/logseq-mcp.git
cd logseq-mcp
uv sync
uv run logseq-mcp
```

### 调试

```bash
npx @modelcontextprotocol/inspector uv --directory . run logseq-mcp
```

---

## 16. 依赖关系图

### 模块间依赖

```
server.py ─────────────────────────────────────────────
  ├── config/settings.py          (配置)
  ├── client/logseq.py            (HTTP 客户端)
  ├── services/blocks.py          (块服务)
  ├── services/pages.py           (页服务)
  ├── services/queries.py         (查询服务)
  ├── services/graph.py           (图谱服务)
  ├── handlers/tools.py           (工具处理器)
  └── handlers/prompts.py         (提示处理器)

handlers/tools.py ─────────────────────────────────────
  ├── models/enums.py             (ToolName 枚举)
  ├── models/schemas.py           (所有输入模型)
  ├── services/blocks.py
  ├── services/pages.py
  ├── services/queries.py
  ├── services/graph.py
  └── utils/errors.py             (错误转换)

handlers/prompts.py ───────────────────────────────────
  ├── services/blocks.py
  └── services/pages.py

services/*.py ─────────────────────────────────────────
  ├── client/logseq.py            (HTTP 客户端)
  ├── models/schemas.py           (输入模型)
  └── models/responses.py         (输出实体 + 格式化器)

client/logseq.py ──────────────────────────────────────
  └── client/base.py              (抽象基类)

client/base.py ────────────────────────────────────────
  ├── config/settings.py
  └── utils/errors.py             (异常类)
```

### 外部依赖

| 包 | 版本 | 用途 |
|----|------|------|
| `mcp` | >=1.2.1 | MCP 协议 SDK (Server, Types) |
| `pydantic` | >=2.10.2 | 数据模型验证 |
| `pydantic-settings` | >=2.0.0 | 环境变量配置管理 |
| `python-dotenv` | >=1.0.1 | .env 文件加载 |
| `requests` | >=2.32.3 | HTTP 客户端 |
| `tenacity` | >=8.2.0 | 重试机制 |

---

> **文档生成日期**: 2026-02-07
> **基于代码版本**: v1.1.0 (commit on main branch)
